<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>FourchLang Snake</title>

    <link rel="stylesheet" href="./assets/style.css">

    <style>
        body {
            font-family: monospace;
            background: #111;
            color: #eee;
        }
        #hud {
            margin-bottom: 8px;
        }
        #game-over {
            margin-top: 8px;
            display: none;
        }
        button {
            margin-left: 8px;
        }
    </style>
</head>

<body>

<div id="hud">
    Score: <span id="score">0</span>
    &nbsp;|&nbsp;
    ContrÃ´les : ZQSD / flÃ¨ches
</div>

<pre id="grid"></pre>

<div id="game-over">
    <span id="game-over-text"></span>
    <button id="restart">Rejouer</button>
</div>

<script src="./assets/ia/index.js"></script>

<script>
    const config = {
  "width": 10,
  "height": 10,
  "player": {
    "x": 2,
    "y": 1,
    "color": "green"
  },
  "snakeBodies": [
    {
      "x": 3,
      "y": 1,
      "name": "owo"
    },
    {
      "x": 4,
      "y": 1,
      "name": "awa"
    },
    {
      "x": 5,
      "y": 1,
      "name": "ewe"
    }
  ],
  "enemies": [
    {
      "x": 8,
      "y": 9,
      "len": 4,
      "speed": 1
    }
  ],
  "enemyBodies": [
    {
      "x": 7,
      "y": 9,
      "name": "koopa"
    },
    {
      "x": 6,
      "y": 9,
      "name": "goomba"
    },
    {
      "x": 5,
      "y": 9,
      "name": "piranha"
    }
  ],
  "walls": [],
  "fruits": [
    {
      "x": 4,
      "y": 5,
      "points": 1
    }
  ],
  "border": {
    "horizontalCrossable": true,
    "verticalCrossable": true
  },
  "fruitConfig": {
    "reappear": true,
    "growthBy": 0
  },
  "gameOver": {
    "hitSnakeBody": true,
    "hitEnemy": true,
    "hitBorder": false,
    "hitWall": false
  }
};
    const playerColor = "green";
    document.documentElement.style.setProperty("--player-color", playerColor);

    const width = config.width;
    const height = config.height;

    const container = document.getElementById("grid");
    const scoreSpan = document.getElementById("score");
    const gameOverDiv = document.getElementById("game-over");
    const gameOverText = document.getElementById("game-over-text");
    const restartBtn = document.getElementById("restart");

    let loopId = null;
    let gameStarted = false;

    // --- STATE ---------------------------------------------------------

    let snake = [];
    snake.push({ x: config.player.x, y: config.player.y });
    if (Array.isArray(config.snakeBodies)) {
        for (const sb of config.snakeBodies) {
            snake.push({ x: sb.x, y: sb.y });
        }
    }

    let fruits = (config.fruits ?? []).map(f => ({
        x: f.x, y: f.y, points: f.points
    }));

    const walls = config.walls ?? [];
    const enemies = config.enemies ?? [];
    const enemyBodies = config.enemyBodies ?? [];

    const border = config.border ?? {
        horizontalCrossable: false,
        verticalCrossable: false
    };

    const rawFruitConfig = config.fruitConfig ?? {};
    const fruitConfig = {
        reappear: !!rawFruitConfig.reappear,
        seconds: typeof rawFruitConfig.seconds === "number" ? rawFruitConfig.seconds : undefined,
        growthBy: typeof rawFruitConfig.growthBy === "number" ? rawFruitConfig.growthBy : 0
    };

    const gameOverConfig = config.gameOver ?? {
        hitSnakeBody: true,
        hitEnemy: true,
        hitBorder: true,
        hitWall: true
    };

    let direction = { x: 0, y: 0 };
    let nextDirection = { x: 0, y: 0 };
    let score = 0;
    let pendingGrowth = 0;
    let isGameOver = false;

    const TICK_MS = 200;

    // --- UTILS ---------------------------------------------------------

    function samePos(a, b) { return a.x === b.x && a.y === b.y; }
    function posInArray(pos, arr) { return arr.some(p => samePos(p, pos)); }

    function allOccupiedPositions() {
        return [...snake, ...fruits, ...walls, ...enemies, ...enemyBodies];
    }

    function randomFreeCell() {
        const occ = new Set(allOccupiedPositions().map(p => `${p.x},${p.y}`));
        const free = [];
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                if (!occ.has(`${x},${y}`)) free.push({ x, y });
            }
        }
        return free[Math.floor(Math.random() * free.length)] ?? null;
    }

    function spawnFruit() {
        const cell = randomFreeCell();
        if (cell) fruits.push({ x: cell.x, y: cell.y, points: 1 });
    }

    function setGameOver(reason) {
        if (isGameOver) return;
        isGameOver = true;
        clearInterval(loopId);
        gameOverText.textContent = `Game over: ${reason}. Score = ${score}`;
        gameOverDiv.style.display = "block";
    }

    // --- INPUT ---------------------------------------------------------

    document.addEventListener("keydown", (event) => {
        const key = event.key.toLowerCase();
        let newDir = null;

        if (key === "arrowup" || key === "z") newDir = { x: 0, y: -1 };
        if (key === "arrowdown" || key === "s") newDir = { x: 0, y: 1 };
        if (key === "arrowleft" || key === "q") newDir = { x: -1, y: 0 };
        if (key === "arrowright" || key === "d") newDir = { x: 1, y: 0 };

        if (!newDir) return;

        if (!gameStarted) {
            gameStarted = true;
            nextDirection = newDir;
            direction = newDir;
            startGame();
            return;
        }

        if (snake.length > 1 &&
            newDir.x === -direction.x &&
            newDir.y === -direction.y) return;

        nextDirection = newDir;
    });

    restartBtn.addEventListener("click", () => window.location.reload());

    // --- IA : mouvement des ennemis ------------------------------------

    function moveEnemies(grid) {

        for (const e of enemies) {

            const ia = FourchIA.greedy; // IA par dÃ©faut

            const ctx = {
                width, height,
                walls, fruits,
                snake,
                border,
                player: snake[0]
            };

            const dir = ia.compute(grid, e, ctx);
            if (!dir) continue;

            let nx = e.x + dir.x;
            let ny = e.y + dir.y;

            // gestion des bords
            if (nx < 0 || nx >= width) {
                if (border.horizontalCrossable) nx = (nx + width) % width;
                else continue;
            }
            if (ny < 0 || ny >= height) {
                if (border.verticalCrossable) ny = (ny + height) % height;
                else continue;
            }

            // collisions simples
            if (posInArray({ x: nx, y: ny }, walls)) continue;
            if (posInArray({ x: nx, y: ny }, enemies)) continue;
            if (posInArray({ x: nx, y: ny }, enemyBodies)) continue;

            // DÃ©placement tÃªte
            e.x = nx;
            e.y = ny;

            // TODO : dÃ©placer les body segments
        }
    }

    // --- STEP -----------------------------------------------------------

    function step() {
        if (isGameOver) return;

        // crÃ©er une version grille pour IA/logic
        const grid = Array.from({ length: height }, () =>
            Array.from({ length: width }, () => ".")
        );

        walls.forEach(w => grid[w.y][w.x] = "W");
        fruits.forEach(f => grid[f.y][f.x] = "F");
        enemies.forEach(en => grid[en.y][en.x] = "M");
        enemyBodies.forEach(b => grid[b.y][b.x] = "X");
        snake.forEach((s, i) => grid[s.y][s.x] = i === 0 ? "O" : "S");

        // ðŸ”¥ 1) IA ennemis
        moveEnemies(grid);

        // ðŸ”¥ 2) dÃ©placement du joueur
        direction = nextDirection;

        const head = snake[0];
        let newHead = { x: head.x + direction.x, y: head.y + direction.y };

        // bords
        if (newHead.x < 0 || newHead.x >= width) {
            if (border.horizontalCrossable) newHead.x = (newHead.x + width) % width;
            else return setGameOver("hit border");
        }
        if (newHead.y < 0 || newHead.y >= height) {
            if (border.verticalCrossable) newHead.y = (newHead.y + height) % height;
            else return setGameOver("hit border");
        }

        const newSnake = [newHead, ...snake];
        if (pendingGrowth > 0) pendingGrowth--;
        else newSnake.pop();

        // collisions
        if (gameOverConfig.hitSnakeBody) {
            for (let i = 1; i < newSnake.length; i++) {
                if (samePos(newHead, newSnake[i])) return setGameOver("hit snake body");
            }
        }
        if (gameOverConfig.hitWall && posInArray(newHead, walls)) return setGameOver("hit wall");
        if (gameOverConfig.hitEnemy && posInArray(newHead, enemies)) return setGameOver("hit enemy");

        let ateFruit = false;
        for (let i = 0; i < fruits.length; i++) {
            if (samePos(newHead, fruits[i])) {
                ateFruit = true;
                score += fruits[i].points ?? 1;
                fruits.splice(i, 1);
                pendingGrowth += fruitConfig.growthBy;
                scoreSpan.textContent = String(score);
                break;
            }
        }

        if (ateFruit && fruitConfig.reappear) spawnFruit();

        snake = newSnake;
        render();
    }

    // --- RENDER ---------------------------------------------------------

    function render() {
        const grid = Array.from({ length: height }, () =>
            Array.from({ length: width }, () => ".")
        );

        walls.forEach(w => grid[w.y][w.x] = "W");
        fruits.forEach(f => grid[f.y][f.x] = "F");
        enemies.forEach(e => grid[e.y][e.x] = "M");
        enemyBodies.forEach(e => grid[e.y][e.x] = "X");

        for (let i = snake.length - 1; i >= 0; i--) {
            const s = snake[i];
            grid[s.y][s.x] = i === 0 ? "O" : "S";
        }

        let html = "";
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const c = grid[y][x];
                html += {
                    O: `<span class="player">O </span>`,
                    S: `<span class="snake-body">S </span>`,
                    M: `<span class="enemy">M </span>`,
                    X: `<span class="enemy-body">X </span>`,
                    F: `<span class="fruit">F </span>`,
                    W: `<span class="wall"># </span>`
                }[c] ?? `<span class="empty">. </span>`;
            }
            html += "<br>";
        }
        container.innerHTML = html;
    }

    // --- START ----------------------------------------------------------

    function startGame() {
        loopId = setInterval(step, TICK_MS);
    }

    render();

</script>
</body>
</html>
