# Table de correspondance métamodèle ↔ AST

| Concept UML (PUML)      | Nœud AST                    | Attributs/Props AST             | Arbitrage/Commentaire                                 |
|-------------------------|-----------------------------|----------------------------------|-------------------------------------------------------|
| GameSession             | Model                       | ennemies, grid, player, scoring, fruit_generation, fruits, game_over_conditions | Fusion : Model du DSL regroupe la session, le plateau et presque tout l’état global. GameSession isolé dans UML, fusionné pour simplifier le DSL. |
| Map                     | Grid puis GameOverCondition et FruitGenerator | x, y (Grid) ; params spécifiques (GameOverCondition, FruitGenerator) | Eclatement : Grid ne reprend qu'une partie (dimension) du concept Map ; les propriétés comme la franchissabilité des bords et la réapparition sont prises en charge par GameOverCondition et FruitGenerator. |
| Tile/Wall/EmptyTile     | (non représentés)           | -                                | Suppression : le DSL n’instancie pas les cases individuelles, mais gère globalement leur contenu via Grid et les positions des objets. |
| Mode (Enum)             | (non représenté)            | -                                | Suppression/Ajout à prévoir si variantes gérées dynamiquement ; non inclus dans la version AST ici. |
| Fruit                   | Fruit / FruitGenerator      | x, y (Fruit) / seconds (FruitGenerator) | Séparation/Ajout : Le métamodèle distingue les points sur les fruits, l’AST sépare les instances de Fruits et leur générateur d’apparition. |
| Enemy                   | Enemy                      | speed, x, y                      | Correspondance, le concept Enemy garde son nom, la capacité de déplacement est gérée via l’attribut de vitesse (speed). La distinction statique/dynamique reste à la charge de la logique ou des attributs. |
| Player                  | Player                      | len, speed, x, y                 | Fusion/Paramétrisation : SnakePlayer et PacManPlayer fusionnés, via un type paramétrable, géré par des attributs (len = taille, speed = vitesse). |
| SnakeBody               | (non représenté)            | -                                | Suppression : En AST, la taille du serpent gérée par Player.len ; le corps segmenté n’est pas explicitement modélisé. |
| Scoring                 | Scoring                     | point, length                    | Correspondance directe, propriétés adaptées à la notion de points et au score évolutif. |
| GameOverCondition       | GameOverCondition           | end (borders, ennemies, fruits)  | Renommage/Simplification : La diversité des conditions de fin est résumée dans l’AST à une interface paramétrable. |
| Direction (Enum)        | (non représenté)            | -                                | Suppression : L’AST ne comprend pas d’enum direction ; les déplacements sont laissés à la logique d’exécution ou au moteur cible. |

## Arbitrages et justifications

- **Fusions** : Plusieurs concepts liés à la gestion et à la mécanique globale (GameSession, Map, Score, etc.) sont centralisés dans Model pour simplifier l’orchestration et la gestion des sous-entités.
- **Renommages** : Le vocabulaire du DSL évolue pour mieux coller à la cible technique ou au domaine métier (Map/Grid).
- **Suppressions** : Les cases individuelles (Tile, Wall, EmptyTile) ou les variantes de Player/Enemy (statique/dynamique, Snake/Pacman) sont absentes pour favoriser la concision et la paramétrabilité.
- **Ajouts/Séparations** : La gestion des générateurs (FruitGenerator) est éclatée pour distinguer l’état d’un objet et son apparition, offrant plus de souplesse pour les variantes du jeu.
- **Non-représentations** : Les enums (direction, mode de jeu) sont omis pour garder le modèle léger, mais pourront évoluer si la diversité des modes ou mouvements devient utile.

## Limites et évolutions attendues

- Pour modéliser précisément chaque mécanique (Snake/Pacman), des distinctions explicites de type de joueur·euse et de gestion du corps du serpent pourraient être rajoutées ; l’actuelle fusion dans Player via len est efficace mais moins fine.
- L’absence de Tile ou de case individuelle limite la finesse spatiale mais améliore les performances et la clarté pour des grilles raisonnables.
- Les conditions de fin de partie sont simplifiées mais pourront recevoir d’autres critères (score, temps, objets spéciaux) via des paramètres supplémentaires.

Cette comparaison a été faite à partir de la version du ast.ts actuelle au TP 2. La voici : 
```typescript

/******************************************************************************
 * This file was generated by langium-cli 4.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const FourchLangTerminals = {
    WS: /\s+/,
    NUM: /[0-9]+[\w_]*/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type FourchLangTerminalNames = keyof typeof FourchLangTerminals;

export type FourchLangKeywordNames =
    | "("
    | ")"
    | "*"
    | ","
    | "and"
    | "borders"
    | "does"
    | "eaten"
    | "end"
    | "ennemies"
    | "Enemy"
    | "every"
    | "fruit"
    | "fruits"
    | "game"
    | "grid"
    | "grow"
    | "in"
    | "moves"
    | "not"
    | "player"
    | "reappear"
    | "score"
    | "size"
    | "speed"
    | "variable"
    | "when"
    | "with"
    | "x";

export type FourchLangTokenNames = FourchLangTerminalNames | FourchLangKeywordNames;

export interface Enemy extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'Enemy';
    speed?: string;
    x: string;
    y: string;
}

export const Enemy = {
    $type: 'Enemy',
    speed: 'speed',
    x: 'x',
    y: 'y'
} as const;

export function isEnemy(item: unknown): item is Enemy {
    return reflection.isInstance(item, Enemy.$type);
}

export interface Fruit extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'Fruit';
    x: string;
    y: string;
}

export const Fruit = {
    $type: 'Fruit',
    x: 'x',
    y: 'y'
} as const;

export function isFruit(item: unknown): item is Fruit {
    return reflection.isInstance(item, Fruit.$type);
}

export interface FruitGenerator extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'FruitGenerator';
    seconds?: string;
}

export const FruitGenerator = {
    $type: 'FruitGenerator',
    seconds: 'seconds'
} as const;

export function isFruitGenerator(item: unknown): item is FruitGenerator {
    return reflection.isInstance(item, FruitGenerator.$type);
}

export interface GameOverCondition extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'GameOverCondition';
    end: 'borders' | 'ennemies' | 'fruits';
}

export const GameOverCondition = {
    $type: 'GameOverCondition',
    end: 'end'
} as const;

export function isGameOverCondition(item: unknown): item is GameOverCondition {
    return reflection.isInstance(item, GameOverCondition.$type);
}

export interface Grid extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'Grid';
    x: string;
    y: string;
}

export const Grid = {
    $type: 'Grid',
    x: 'x',
    y: 'y'
} as const;

export function isGrid(item: unknown): item is Grid {
    return reflection.isInstance(item, Grid.$type);
}

export interface Model extends langium.AstNode {
    readonly $type: 'Model';
    ennemies: Array<Enemy>;
    fruit_generation: Array<FruitGenerator>;
    fruits: Array<Fruit>;
    game_over_conditions: Array<GameOverCondition>;
    grid: Array<Grid>;
    player: Array<Player>;
    scoring: Array<Scoring>;
}

export const Model = {
    $type: 'Model',
    ennemies: 'ennemies',
    fruit_generation: 'fruit_generation',
    fruits: 'fruits',
    game_over_conditions: 'game_over_conditions',
    grid: 'grid',
    player: 'player',
    scoring: 'scoring'
} as const;

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model.$type);
}

export interface Player extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'Player';
    len: string;
    speed?: string;
    x?: string;
    y?: string;
}

export const Player = {
    $type: 'Player',
    len: 'len',
    speed: 'speed',
    x: 'x',
    y: 'y'
} as const;

export function isPlayer(item: unknown): item is Player {
    return reflection.isInstance(item, Player.$type);
}

export interface Scoring extends langium.AstNode {
    readonly $container: Model;
    readonly $type: 'Scoring';
    length?: string;
    point: string;
}

export const Scoring = {
    $type: 'Scoring',
    length: 'length',
    point: 'point'
} as const;

export function isScoring(item: unknown): item is Scoring {
    return reflection.isInstance(item, Scoring.$type);
}

export type FourchLangAstType = {
    Enemy: Enemy
    Fruit: Fruit
    FruitGenerator: FruitGenerator
    GameOverCondition: GameOverCondition
    Grid: Grid
    Model: Model
    Player: Player
    Scoring: Scoring
}

export class FourchLangAstReflection extends langium.AbstractAstReflection {
    override readonly types = {
        Enemy: {
            name: Enemy.$type,
            properties: {
                speed: {
                    name: Enemy.speed
                },
                x: {
                    name: Enemy.x
                },
                y: {
                    name: Enemy.y
                }
            },
            superTypes: []
        },
        Fruit: {
            name: Fruit.$type,
            properties: {
                x: {
                    name: Fruit.x
                },
                y: {
                    name: Fruit.y
                }
            },
            superTypes: []
        },
        FruitGenerator: {
            name: FruitGenerator.$type,
            properties: {
                seconds: {
                    name: FruitGenerator.seconds
                }
            },
            superTypes: []
        },
        GameOverCondition: {
            name: GameOverCondition.$type,
            properties: {
                end: {
                    name: GameOverCondition.end
                }
            },
            superTypes: []
        },
        Grid: {
            name: Grid.$type,
            properties: {
                x: {
                    name: Grid.x
                },
                y: {
                    name: Grid.y
                }
            },
            superTypes: []
        },
        Model: {
            name: Model.$type,
            properties: {
                ennemies: {
                    name: Model.ennemies,
                    defaultValue: []
                },
                fruit_generation: {
                    name: Model.fruit_generation,
                    defaultValue: []
                },
                fruits: {
                    name: Model.fruits,
                    defaultValue: []
                },
                game_over_conditions: {
                    name: Model.game_over_conditions,
                    defaultValue: []
                },
                grid: {
                    name: Model.grid,
                    defaultValue: []
                },
                player: {
                    name: Model.player,
                    defaultValue: []
                },
                scoring: {
                    name: Model.scoring,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Player: {
            name: Player.$type,
            properties: {
                len: {
                    name: Player.len
                },
                speed: {
                    name: Player.speed
                },
                x: {
                    name: Player.x
                },
                y: {
                    name: Player.y
                }
            },
            superTypes: []
        },
        Scoring: {
            name: Scoring.$type,
            properties: {
                length: {
                    name: Scoring.length
                },
                point: {
                    name: Scoring.point
                }
            },
            superTypes: []
        }
    } as const satisfies langium.AstMetaData
}

export const reflection = new FourchLangAstReflection();
```